---
title: "Week 2"
author: "Pernille Brams feat. Kathrine Schultz-Nielsen"
date: "22/2/2024"
output:
  html_document:
    toc: true  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Setting my root directory to where I have my /data folder etc. (easier for me, but personalise to your own way of working)
knitr::opts_knit$set(root.dir = "/Users/niels/Desktop/University/Second Semester/Methods 2/Github Repo Local/resources")
```

```{r libs}
library(pacman)

pacman::p_load(tidyverse,
               ggpubr)

```

# Learning about for loops, if-else statements, functions - and practicing simulating!
(Lots of stuff in chapter 4-5 about this)

Loops can be good for simulating. And they are cool. Let's practice is a bit.

## Exercises to practise loops (discuss with partner/group if you want to)
### Ex. A: What is the difference between a for- and a while loop? Explain in your own words in 1-2 sentences.
A for loop goes through a list/sequence of finite length and applies something for each element. A while loop continuously does a function until a given criteria is no longer true. 

### Ex. B: When would you use for-loops and when would you use while-loops? Explain in your own words in 1-2 sentences
If I had some sort of criteria that is calculated for something, but I want to stop it when it reaches some threshhold I would use a while-loop. If I on the other hand have some list of elements that I want to calculate values for each, then I would use a for loop. 

### Ex. C: Create and run both a simple for and a while loop
I've made an example below. Make your own example below it. If you have no ideas for what to code in your for loop, here's an example you can try to code up:
- A simple for loop could be for each i in 1:20, print i if i is above 3
```{r}
# Here's a simple for-loop
#for (i in 1:10){ # For each i in 1:10...
 # print(i+5)    # Do this..
#}

# your simple loop here
watermelons <- 10
list_watermelons <- seq(1, watermelons, 1)
df_wm_weight <- data.frame(list_watermelons)
possible_weight <- rnorm(500, mean = 2000,sd = 350)

for (i in list_watermelons){
  watermelon_weight <- sample(possible_weight, 1)
  print(watermelon_weight)
}
```

I've also made an example of a while loop below. Make your own example below it. If you have no ideas for what to code in your while loop, here's an example you can try to code up:
- A simple while loop could be while some_number is below 20, print("the number is below 20, so I still run! (until it isn't true anymore)". Each time it 'checks' make sure to add some number to the some_number - could be 7
```{r}
# A simple while-loop
#number = 0
#while (number < 10){ # While the number is below 10, do the following
 # print(number)
# number = number + 1
#}

# your simple while-loop here
watermelons <- 10
list_watermelons <- seq(1, watermelons, 1)
df_wm_weight <- data.frame(list_watermelons)
possible_weight <- rnorm(500, mean = 2000,sd = 350)
total_weight <- 0

for (i in list_watermelons){
    while (total_weight < 10000){
  watermelon_weight <- sample(possible_weight, 1)
  print(i)
  print(watermelon_weight)
  total_weight = watermelon_weight + total_weight
  print("Total weight")
  print(total_weight)
  } # end of while loop
} # end of for loop
# I didn't end up making it work, because my example is weird.
```

## Exercises to practise functions and if-else statements
### Ex. D: Write a function in R that converts temperature from Fahrenheit to Celsius.
Create a function that accepts a temperature in Fahrenheit and returns the temperature converted to Celsius. The formula to convert Fahrenheit to Celsius is: C = (F-32)*5/9.
```{r}
# Function to convert Fahrenheit to Celsius
convert_to_celsius <- function(fahrenheit) {
  # Your code here
  # Hint: Apply the conversion formula within the function
  celsius <- (fahrenheit-32)*5/9
  return(celsius)
}

# Example of how the final function (when you've written it) should be used:
# temp_celsius <- convert_to_celsius(68)
# print(temp_celsius)
# Expected Output (for fahrenheit = 68): 20

convert_to_celsius(50)
```

### Ex. E: Write a function in R that provides clothing advice based on the temperature:
Create a function that accepts the current temperature (in Celsius) as an argument and returns advice on what type of clothing to wear. The function should use if-else statements to determine the appropriate clothing advice.

Here's the advice that your function should give based on the conditions:

If the temperature is above 25 degrees Celsius, suggest wearing a T-shirt.
If the temperature is between 15 and 25 degrees (inclusive), suggest wearing a light jacket.
If the temperature is below 15 degrees, suggest wearing a warm coat.

Use statements if, else if, and else. Google how to set up the syntax with curly brackets and so on if you're not sure.
```{r}
# Function to give clothing advice based on temperature
clothing_advice <- function(temperature) {
  # Your code here
  # Hint: Use if-else statements to check the temperature and return the advice
  if (temperature > 25) {
    return("Wear a T_shirt")
  } else if (temperature > 15 && temperature < 25){
    return("Wear a light jacket")
  } else {
    return("Wear a warm coat")
  }
}

# Example of how the final function (when you've written it) should be used:
# advice <- clothing_advice(20)
# print(advice)
# Expected Output (for temperature = 20): "Wear a light jacket."
advice <- clothing_advice(14)
print(advice)
```

## Exercises from the book

## Ex. 0: Write up / copy the code found on page 69-70 in chapter 5 ROS and note whats going on at each step. The book explains it - so just go through it and discuss with your group to understand whats going on.
first it makes a random binomial distribution of 400, basically selecting if they are a girl or a boy each time for 400 with a slightly lower probability for being a girl (48.8%). Then it repeats this simulation 1000 times. 

### Ex. 5.1 Discrete probability simulation: Suppose that a basketball player has a 60% chance of making a shot, and he keeps taking shots until he misses two in a row. Also assume his shots are independent (so that each shot has 60% probability of success, no matter what happened before).
* Hint 3 and 4

#### Ex. 5.1.a) Write an R function to simulate this process.
Here's some notes to get you started: 

- We're told that the basketball player has 60% chance of making the shot
- We're told he keeps shooting until missing two in a row
- We're also told to assume that his shots are independent, all having 60% of probability of success

To simulate the process we can list the variables that we'll need to record based on what we're told: 
We need to record: 
- probability of making the shot
- number of misses in a row (we need something that can count it because we know he stops when missing 2)
- number of hits in a row (to see how many he gets)
- shots taken

Let's try and write a function:
```{r}
basketball <- function(p_success, max_misses) {
  shot_n <- 0
  misses_in_row <- 0
  hits_in_row <- 0
  shots <- numeric() # to store shot results (1 for hit, 0 for miss)
  
  while (misses_in_row < max_misses) {
    shot <- rbinom(1, size = 1, prob = p_success)
    shot_n <- shot_n + 1
    shots[shot_n] <- shot
    
    if (shot == 1) {
      hits_in_row <- hits_in_row + 1
      misses_in_row <- 0
    } else {
      misses_in_row <- misses_in_row + 1
      hits_in_row <- 0
    }
  }
  
  tot_shots <- length(shots)
  shot_successful <- shots
  result_df <- data.frame(tot_shots = 1:tot_shots, shot_successful)
  
  return(result_df)
}


df_1_sim_basket <- basketball(p_success = 0.6, max_misses = 2)
```

```{r}
n_sims <- 1000
max_misses <- 2
p_success <- 0.6
total_shots_vector <- numeric(n_sims)
total_hits_vector <- numeric(n_sims)

for (i in 1:n_sims){
  sim_result <- basketball(p_success, max_misses)
  total_shots_vector[i] <- nrow(sim_result)
  total_hits_vector[i] <- sum(sim_result$shot_successful)
  
}

mean_shots <- mean(total_shots_vector)
sd_shots <- sd(total_shots_vector)
mean_shots
sd_shots
```



#### Ex. 5.1.b) Put the R function in a loop to simulate the process 1000 times. Use the simulation to estimate the mean and standard deviation of the total number of shots that the player will take, and plot a histogram representing the distribution of this random variable. 
```{r}
# done above
```

#### Ex. 5.1.c) Using your simulations, make a scatterplot of the number of shots the player will take and the proportion of shots that are successes.
```{r}
# your code here
# Calculate the average proportion of hits from the simulations list
total_hits <- sum(total_hits_vector)
total_shots <- sum(total_shots_vector)
hit_rate_1000 <- total_hits/total_shots

print(paste("Average proportion of hits:", hit_rate_1000))

```

### Ex. 5.3: Binomial distribution: A player takes 10 basketball shots, with a 40% probability of making each shot. Assume the outcomes of the shots are independent.
#### Ex. 5.3.a) Write a line of R code to compute the probability that the player makes exactly 3 of the 10 shots.
```{r}
# your code here
prob_3_10 <-  dbinom(3, size = 10, prob = 0.4)
prob_3_10
```

#### Ex. 5.3.b) Write an R function to simulate the 10 shots. Loop this function 10 000 times and check that your simulated probability of making exactly 3 shots is close to the exact probability computed in (a).
```{r}
# your code here
basketball_5.3 <- function(p_success, shots, goal_shots) {
  total_shots <- numeric(shots)
  for (s in 1:shots){
    shot <- rbinom(1, size = 1, prob = p_success)
    #print(s)
    #print(paste0(c("Shot number: ", s, "Value: ", shot)))
    total_shots[s] <- shot
    #print(paste0(c("Total_shots", total_shots)))
  }
  if (sum(total_shots) == goal_shots){
    return(1)
  } else {
    return(0)
  }
}

n_sims <- 10000
exactly_3_vector <- numeric(n_sims)
for (sim in 1:n_sims){
  sim_result <- basketball_5.3(p_success = 0.4, shots = 10, goal_shots = 3)
  exactly_3_vector[sim] <- sim_result
}
total_3s <- sum(exactly_3_vector)
prob_3_10_sim <- total_3s/n_sims
```

## Ex. 5.4: Demonstration of the Central Limit Theorem: Let x = x1 + · · · + x20, the sum of 20 independent uniform(0, 1) random variables. In R, create 1000 simulations of x and plot their histogram. What is the normal approximation to this distribution provided by the Central Limit Theorem? Overlay a graph of the normal density on top of the histogram. Comment on any differences between the histogram and the curve.

(Recall the Central limit theorem (CLT) on the bottom of page 51 and from Methods 1)
```{r}
# your code here
# Step 1: Generate 1000 simulations of x
set.seed(123) # For reproducibility
x_simulations <- replicate(1000, sum(runif(20, 0, 1)))

# Step 2: Plot the histogram
hist(x_simulations, breaks=40, probability=TRUE, col="skyblue", main="Histogram of 1000 simulations of x", xlab="Sum of 20 uniform(0,1) RVs")

# Step 3: Normal approximation parameters
mu <- 10 # mean which is 10, because 20*(the mean of each uniform(0,1) RV) = 20*0.5 = 10
sigma <- sqrt(5/3) # standard deviation which is sqrt(20*(the variance of each uniform(0,1) RV)) = sqrt(20*(1/12)) = sqrt(5/3)

# Step 4: Overlay the normal density curve
curve(dnorm(x, mean=mu, sd=sigma), add=TRUE, col="red", lwd=2)
```
The histogram has a slightly higher density around the mode than the normal distribution. This is because the normal distribution is an approximation and the histogram is the actual distribution. The normal distribution is a good approximation, but not perfect.

## Ex. 5.5: Distribution of averages and differences: The heights of men in the United States are approximately normally distributed with mean 69.1 inches and standard deviation 2.9 inches. The heights of women are approximately normally distributed with mean 63.7 inches and standard deviation 2.7 inches. Let x be the average height of 100 randomly sampled men, and y be the average height of 100 randomly sampled women. In R, create 1000 simulations of x − y and plot their histogram. Using the simulations, compute the mean and standard deviation of the distribution of x − y and compare to their exact values.
*Hint 1

```{r}
# your code here
n_sims <- 10000 # how many times?
store_diff <- rep(NA, n_sims) # vector to store result of each simulation
#print(store_diff) 
for (n in 1:n_sims){ # function to do simulation n times
  m_h <- rnorm(100, mean = 69.1, sd = 2.9)
  w_h <- rnorm(100, mean = 63.7, sd = 2.7)
  diff <- mean(m_h) - mean(w_h)
  store_diff[n] <- diff
  #print(diff)
}
df_h_5.5 <- data.frame(1:n_sims, store_diff)
ggplot(data = df_h_5.5, aes(x = store_diff)) +
  geom_histogram(binwidth = 0.05, fill = "blue", color = "black") +
  theme_minimal()

# compare their exact values
mean_diff <- mean(store_diff)
mean_diff
sd_diff <- sd(store_diff)
sd_diff
```

## Ex. 5.8: Coverage of confidence intervals: On page 15 there is a discussion of an experimental study of an education-related intervention in Jamaica, in which the point estimate of the treatment effect, on the log scale, was 0.35 with a standard error of 0.17. Suppose the true effect is 0.10 — this seems more realistic than the point estimate of 0.35 — so that the treatment on average would increase earnings by 0.10 on the log scale. Use simulation to study the statistical properties of this experiment, assuming the standard error is 0.17.
*Hint 2

```{r}
# your code here
```

#### Ex. 5.8.a) Simulate 1000 independent replications of the experiment assuming that the point estimate is normally distributed with mean 0.10 and standard deviation 0.17.
(In the experiment on page 15, we see n = 127 children)
```{r}
# your code here
set.seed(420)
n <- 127
mu <- 0.10
sd <- 0.17
n_sims <- 1000
store_estimate <- rep(NA, n_sims)

for (i in 1:n_sims){
  sim_result <- rnorm(n, mean = mu, sd = sd)
  store_estimate[i] <- mean(sim_result)
}
```

#### Ex. 5.8.b) For each replication, compute the 95% confidence interval. Check how many of these intervals include the true parameter value.
```{r}
# your code here
store_estimate_df <- data.frame(store_estimate = store_estimate)
store_estimate_df$lower <- store_estimate_df$store_estimate - 1.96 * sd / sqrt(n)
store_estimate_df$upper <- store_estimate_df$store_estimate + 1.96 * sd / sqrt(n)

store_estimate_df$true_param <- ifelse(store_estimate_df$lower <= mu & store_estimate_df$upper >= mu, 1, 0)
inclusive_intervals <- sum(store_estimate_df$true_param)
inclusive_intervals

```

#### Ex. 5.9: Coverage of confidence intervals after selection on statistical significance: Take your 1000 simulations from Exercise 5.8, and select just the ones where the estimate is statistically significantly different from zero. Compute the average and standard deviation of the selected point estimates. Compare these to the result from Exercise 5.8.
```{r}
# Calculating the t-value for each estimate
store_estimate_df$t_value <- (store_estimate_df$store_estimate - 0) / (sd / sqrt(n))

# Getting the critical t-value for a 95% CI (two-tailed)
critical_t <- qt(0.975, df = n - 1)

# Identifying significant estimates
store_estimate_df$signif <- ifelse(abs(store_estimate_df$t_value) > critical_t, 1, 0)

# Filtering significant estimates
pacman::p_load(tidyverse)
significant_estimates <- store_estimate_df %>% filter(signif == 1)

# Calculating average and standard deviation of the significant point estimates
average_significant <- mean(significant_estimates$store_estimate)
sd_significant <- sd(significant_estimates$store_estimate)

list(average = average_significant, sd = sd_significant)

```
I get all significant estimates, maybe I am doing something wrong???

# Hints
### Hint 1 (for 5.5)
If you get that far, use that 
$$
\rho_{X, Y}=\operatorname{corr}(X, Y)=\frac{\operatorname{cov}(X, Y)}{\sigma_X \sigma_Y}
$$
### Hint 2 (for 5.8)
If you are stuck figuring out how to find confidence intervals in R have a look here:
https://www.geeksforgeeks.org/how-to-find-confidence-intervals-in-r/

### Hints for 5.1:
Hint 3: Think about what distribution we'll use to simulate from when it's a basketball hit we're talking about here (success/fail type outcome). Rhymes with minomial.
Hint 4: Think about the two loops we have learnt about. When this guy keeps shooting UNTIL something happens (i.e. while something is true), what loop should we use?

# Extra exercises to practice making functions in R + discussing questions

### Prime number checker
A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function should take one argument, which is the number to check, and return TRUE if the number is prime and FALSE otherwise.

#### Ex. 1: Write a function in R that checks whether a given number is a prime number
```{r}
# Function to check if a number is prime
is_prime <- function(number) {
  # Your code here
  # Hint: You may use a while-loop or a for-loop to test divisibility
  # Remember to handle edge cases like numbers less than 2
}

# Example usage:
# result <- is_prime(29)
# print(result)
# Expected Output (for number = 29): TRUE
```

### Fibonacci
The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. The sequence commonly starts with 0 and 1. The function should take one argument, n, which represents the length of the sequence to generate.

#### Ex. 2: Fibonacci Sequence Generator: Write a function in R that generates the Fibonacci sequence up to the n-th term.
```{r}
# Function to generate Fibonacci sequence
generate_fibonacci <- function(n) {
  # Your code here
  # Hint: Initialize the sequence with the first two numbers, then use a for-loop to generate the rest
}

# Example usage:
# fibonacci_sequence <- generate_fibonacci(10)
# print(fibonacci_sequence)
# Expected Output (for n = 10): 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

## Discuss question 1: Consider the study of ovulation and political attitudes on pp. 62-63. Why is this study flawed. Discuss with your neighbor :)

## Discuss question 2: What are the authors 3 suggestions to avoid over-interpretation of noise?

## Optional: If you want more exercises from chapter 4 try 4.1 and 4.2 Hint: In 4.2 use the proportions 50/50 or those given in the example in section "Standard error for a comparison" on pp. 52-53
